#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;

class DefiniteIntegral
{
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsNumber)
    {
        double res = 0.0;
        double width = (b - a) / threadsNumber;
        Barrier barrier = new Barrier(threadsNumber + 1);

        Thread[] threads = new Thread[threadsNumber];
        for (int i = 0; i < threadsNumber; i++)
        {
            double start = a + i * width;
            double end = start + width;

            threads[i] = new Thread(() =>
            {
                double sum = 0.0;
                double x = start;

                while (x < end)
                {
                    double x1 = x;
                    double x2 = x + step;
                    sum += (function(x1) + function(x2)) * (x2 - x1) / 2.0;
                    x = x2;
                }

                Add(ref res, sum);
                barrier.SignalAndWait();
            });
            threads[i].Start();
        }

        barrier.SignalAndWait();
        return res;
    }
    public static double Add(ref double location1, double value)
    {
        double newCurrentValue = location1;
        while (true)
        {
            double currentValue = newCurrentValue;
            double newValue = currentValue + value;
            newCurrentValue = Interlocked.CompareExchange(ref location1, newValue, currentValue);
            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }
    public static double Solve1(double a, double b, Func<double, double> function, double step)
    {
        double s = (function(a) + function(b))/2;
        double s1 = 0;
        for(double i = a + step; i<=b - step; i+= step)
        {
            s1 += function(i);
        }
        return s + s1;
    }
}

#!csharp

double Function(double x)
{
    return Math.Sin(x);
}
double a = 0;
double b = 10;
double requiredAccuracy = 1e-4;
double[] steps = { 1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6 };
double referenceValue = 1 - Math.Cos(10);

double optimalStep = steps[0];
double minError = double.MaxValue;
double optimalTime = 0;

Console.WriteLine($"Эталонное значение: {referenceValue}");
foreach (var step in steps)
{
    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Start();
    double result = DefiniteIntegral.Solve(a, b, Function, step, 1);
    stopwatch.Stop();

    double error = Math.Abs(result - referenceValue);
    double time = stopwatch.Elapsed.TotalMilliseconds;
    Console.WriteLine($"Шаг:{step}, результат: {result}, время выполнения: {time} ms");

    if (error <= requiredAccuracy && time < minError)
    {
        minError = time;
        optimalStep = step;
        optimalTime = time;
    }
}
Console.WriteLine();
Console.WriteLine($"Оптимальный шаг: {optimalStep}, время выполнения: {optimalTime} ms");

#!markdown

Вывод: оптимальный варинт - 1e-4

#!csharp

List<double> x = new();
List<int> y = new();

for (int i = 2; i <= 32; i++)
{
    double totalSeconds = 0;
    int runs = 20;

    for (int j = 0; j < runs; j++)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();
        DefiniteIntegral.Solve(-100, 100, Function, optimalStep, i);
        stopwatch.Stop();
        totalSeconds += stopwatch.Elapsed.TotalSeconds;
    }

    y.Add(i);
    double averageTime = totalSeconds / runs;
    x.Add(averageTime);
    Console.WriteLine($"Кол-во потоков - {i}, время выполнения: {averageTime:F6}");
}
double optimalThreadTime = x.Min();
int optimalThreads = y[x.IndexOf(x.Min())];
Console.WriteLine();
Console.WriteLine($"Лучший вариант: {optimalThreads} потока(ов), время выполнения: {optimalThreadTime}");

#!csharp

#r "nuget:ScottPlot, 5.0.35"
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
    ScottPlot.Plot plt = new();
plt.YLabel("Количество потоков");
plt.XLabel("Время выполнения (s)");
plt.Add.Scatter(x, y);
plt

#!csharp

double singleThreadedTime = 0;
        for (int run = 0; run < 20; run++)
        {
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            double result = DefiniteIntegral.Solve1(-100, 100, Function, optimalStep);
            stopwatch.Stop();

            singleThreadedTime += stopwatch.Elapsed.TotalSeconds;
        }
        singleThreadedTime /= 20;

        Console.WriteLine($"Кол-во потоков - 1, время выполнения: {singleThreadedTime} s");

#!markdown

Summary

#!csharp

double percentageImprovement = ((singleThreadedTime - optimalThreadTime) / singleThreadedTime) * 100;

Console.WriteLine("\nSummary:");
Console.WriteLine($"Оптимальный шаг: {optimalStep}");
Console.WriteLine($"Оптимальное кол-во потоков: {optimalThreads}");
Console.WriteLine($"Среднее время работы многопоточной версии: {optimalThreadTime} s");
Console.WriteLine($"Среднее время работы однопоточной версии: {singleThreadedTime} s");
Console.WriteLine($"Разница в скорости: {percentageImprovement:F2}%");
